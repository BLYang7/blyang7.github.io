---
layout: post
title: Thread线程的声明周期
categories: Java语言

---

>Thread线程创建并启动之后，并不是立即进入执行状态，也不会一直处于执行状态，因为CPU在同一时间点只能处理一个线程。多线程执行时，ＣＰＵ需要在多个线程之间来回切换

#### 声明周期的说明

一个线程的生命周期分为创建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）和死亡（Dead）五种状态。

* 创建：使用new关键字创建一个线程，Java虚拟机为其分配内存，初始化成员变量
* 就绪：线程对象调用start()方法之后，线程就处于就绪状态。但是此时并没有开始运行，只是在等待执行状态。至于何时运行，取决于JVM线程调度器。
* 运行：处于就绪状态的线程获得CPU之后，就会进入运行状态。但是不会一直执行，会被中断，目的是为了让其他线程获得执行的机会。
* 阻塞：线程放弃处理器资源，在合适的时候重新进入就绪状态，阻塞解除，等待线程调度器的调用。
* 死亡：线程结束，分为三种情况，一是run方法执行完毕，二是抛出了一个未被捕获的Exception或者Error，三是程序调用了线程的stop方法（易造成死锁）

**注意，就绪状态和运行状态不受程序控制，由系统的线程调度器所决定**

<br/>

#### 线程的几个常见方法的说明

* start()：让线程进入就绪状态
* run()、call()：直接调用run或者call方法会让系统直接运行两个方法，不会出现多线程，还是按照main单线程的运行，此时的run方法就是一个普通的类方法了，不再作为线程执行体。
* isAlive()：测试线程是否死亡，当处于就绪、运行、阻塞三种状态时，返回true，当处于新建、死亡两种状态时，返回false
* sleep()：让当前线程暂停一段时间，进入阻塞状态
* yield()：线程让步方法，和sleep方法类似，是Thread的一个静态方法。它会让当前的线程暂停，但不会进入阻塞状态，而是进入就绪状态。当前线程调用yield方法暂停之后，只有优先级与当前线程相同，或者是比当前线程优先级高的处于就绪状态的线程才会获得执行的机会。（由于sleep的性能较好，不建议使用yield）
* join()：让一个线程等待另一个线程完成的方法。程序执行中，调用某一个线程的join方法后，当前线程会被阻塞，直到join进来的线程完成为止。
* setDaemon(true)：设置线程为后台线程。后台线程是为其他的线程提供服务，JVM垃圾回收器就是典型的后台线程。当所有的前台线程都死亡之后，后台线程就会自动死亡。
* isDaemon：判断线程是否为后台线程
* setPriority(int  num)：设置线程低优先级，num的范围是1-10

