---
layout: post
title: voliatile和synchronized的区别
categories: Java语言

---

>voliatile保证变量的值的读取和写入是在主存中进行的，多个线程同时可见。而synchronized则是锁定变量，修改之后才允许其他线程获取它

<br/>

#### 一、一个例子

```
	int i1;				public int getI1(){return i1;}
	volatile int i2;	public int getI2(){return i2;}
	int i3;  			synchronized int getI3(){return i3;}
```

**getI1** :

getI1在当前线程中获取i1变量的值，获取主存中的i1值，拷贝到当前线程的内存中。此时获取的变量的值不一定与其他线程获得的值相同。比如说其他线程修改了i1的值，那么当前线程获得的值可能与修改后的值有差别。

Java中有主内存的机制，用于主线程，保存变量当前的值。而其他线程将变量的值拷贝到自己独立的内存中，在线程中修改变量的值时，可能还没有来得及更新主内存中的值，主内存中的变量又被其他线程访问了，此时就会出现差别。

<br/>

**getI2** ：

getI2获取的是主内存中的变量值。volatile修饰的变量不允许线程从主内存中拷贝变量，用它修饰的变量的读取和写入必须都在主内存中进行，所有的线程同步的获取数据。如果有一个线程修改了变量，那么其他线程立即得到同样的值。不过这就使得volatile变量在性能上有所消耗

<br/>

**getI3** ：

getI3用synchronized修饰，synchronized获取和释放有监听器控制的锁，如果两个线程都使用一个监听器，那么监听器强制一个时刻只有一个线程能处理代码块。同时synchronized还保证内存同步，当线程拷贝主线程的中变量之后，修改完成之后再同步到主内存中。然后释放锁，其他线程才能继续访问。

<br/>

#### 二、区别和联系

volatile只能修饰变量，所以一个任一个volatile只能在线程内存和主内存之间同步一个变量的值。

而synchronized是采用监听器的形式，可以同时同步线程内存和主内存之间的所有变量，synchronized的性能消耗更大

**两者的区别**

* volatile本质是告诉JVM当前变量在寄存器（工作内存）中的值是不确定的，需要从主内存中读出和写入。 synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞
* volatile仅能修饰变量，而synchronized则可以修饰变量、方法、类等
* volatile仅能实现变量的修改是同步的，但是不能保证原子性，比如线程A修改了变量还没有结束时，线程B已经看到了修改的值，而且可以继续修改这个值，而不用等待A释放变量。而synchronized则可以保证变量的修改可见性和原子性，同一时刻只能有一个线程在访问变量。
* volatile不会造成线程阻塞，因为它没有锁机制； 而synchronized可能造成线程阻塞
* volatile标记的变量不会被编译器优化，而synchronized标记的变量可以被编译器优化


<br/>

#### 备注

备注一： volatile修饰的变量是自增或者自减时（只涉及自身的操作），volatile失效。

备注二： 锁机制提供了两种主要特性，互斥性和可见性。互斥是指只允许一个线程持有特定的锁，当共享数据时，一次也只有一个线程能够共享数据。可见性是指一个线程释放锁之前对共享数据作出的更改需要对于随后获得该锁的其他线程是可见的，也就是说在释放锁之前，要将寄存器中的变量值同步到主内存中。























 